/*
 * @Description: 
 * @Author: Tong Chen
 * @Date: 2022-07-27 22:59:52
 * @LastEditTime: 2022-07-27 23:17:25
 * @LastEditors:  
 */
/**
 * 62.不同路径
 * @param {number} m
 * @param {number} n
 * @return {number}
 * 
 * 时间复杂度 O(mn)
 * 空间复杂度 O(m) 注意.其实该方法可以再优化, 当案例中的m远大于n时, 可以交换行和列, 或者用里层for循环遍历列, 这样队列只需要维护n个元素
 */

// 思想:
// 假设, 走到 第m行第n列的格子有f(m,n)条不同路径
// 那么只有两种情况走到那里
//   1. 先走到第m-1行第n列的格子, 再往下走一格
//   2. 先走到第m行第n-1列的格子, 再往右走一格
// 因此, f(m,n) = f(m-1,n) + f(m,n-1), 其实就是每个格子的路径数都等于它上面和左边那俩格子的路径数的和

// 并且整张图的第一行和第一列的值都为1
// 因此不管是遍历行还是遍历列, 都跳过1

// 最后, 在决定以什么形式来维护子问题的结果时 发现, 只需要用到1维数组即可
// 数组主要维护两部分的数据, 一部分是该点前一列 -- 从该点左边格子一直到末尾; 另一部分是, 从该点的当前列的头元素 -- 一直到该点的上面元素;
// 因此计算每个点的路径数时, 只需要计算数组头元素和尾元素的和
var uniquePaths = function (m, n) {
  var arr = new Array(m).fill(1)

  // 外层for循环遍历列, 里层for循环遍历行
  for (let i = 1; i < n; i++) {
    arr.push(1) // 每算完一列, 都需要从队尾放入1, 这些1就是整张图的第一行元素
    arr.shift()
    for (let j = 1; j < m; j++) {
      arr.push(arr[0] + arr[arr.length - 1]) // arr[0]就是f(m-1,n), arr[length-1]就是f(m,n-1)
      arr.shift() // 每次添加完新元素, 都要将首元素移出, 保证计算下一个点时, 数组首元素是下一个点的左边元素
    }
  }
  return arr[arr.length - 1]
}